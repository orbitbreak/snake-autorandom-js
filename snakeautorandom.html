<!DOCTYPE html>
<html>
<head>
<title>Snake AutoRandom</title>
<meta charset="UTF-8">
<style>
html, body {
    height: 100%;
    margin: 0;
}

body {
    background: black;
    display: flex;
    align-items: center;
    justify-content: center;
}
canvas {
    border: 1px solid blue;
}
</style>
</head>
<body>

<!-- size must match canvasSideLength in script below -->
<canvas width="400" height="400" id="canvas"></canvas> 

<script>

var canvas = document.getElementById('canvas');
var context = canvas.getContext('2d');

var canvasSideLength = 400;
var canvasSideTiles = 10;
var startOffset = 4;
var grid = canvasSideLength/canvasSideTiles; // must be round number
var gameSpeedCounter = 0;

var snake = {
    x: grid * startOffset, //starting pos
    y: grid * startOffset,
    
    dx: grid, //movement per iter
    dy: 0,
    
    cells: [], //all squares of snakes body, accumulates infinitely
    handleNextMove: function(nextMoveInt){
        console.log("handleNextMove:: handling nextMoveInt=" + nextMoveInt);
        switch(nextMoveInt){
            case 1: //west
                this.dy = 0;
                this.dx = -grid; break;
            case 2: //north
                this.dy = -grid;
                this.dx = 0; break;
            case 3: //east
                this.dy = 0;
                this.dx = grid; break;
            case 4: //south
                this.dy = grid;
                this.dx = 0; break;
            default:
                console.error("in handleNextMove:: unhandled nextMoveInt=" + nextMoveInt);
        }
    },
    detectPrevMove: function(headCell, neckCell){
        let prevMove = 0;
        if (headCell.x > neckCell.x){
            console.log("Detected prevMove=east");
            prevMove = 3; //east
        } else if (headCell.x < neckCell.x){
            console.log("Detected prevMove=west");
            prevMove = 1; //west
        } else if (headCell.y > neckCell.y){
            console.log("Detected prevMove=south");
            prevMove = 4; //south
        } else if (headCell.y < neckCell.y){
            console.log("Detected prevMove=north");
            prevMove = 2; //north
        }
        console.log("detectPrevMove:: returning prevMove=" + prevMove);
        return prevMove;
    },
    pickNextMove: function(turnLeftStraightRight, prevMove){
        let nextMove = 0;
        switch(turnLeftStraightRight){
            case 1: //turn left
                switch(prevMove){
                    case 1: //last moved west
                        nextMove = 4; break; //go south
                    case 2: //last moved north
                        nextMove = 1; break; //go west
                    case 3: //last moved east
                        nextMove = 2; break; //go north
                    case 4: //last moved south
                        nextMove = 3; break; //go east
                    default:
                        console.error("Unhandled prevMove=" + prevMove);
                }; break;
            case 2: //straight 
                switch(prevMove){
                    case 1: //last moved west
                        nextMove = 1; break; //go west
                    case 2: //last moved north
                        nextMove = 2; break; //go north
                    case 3: //last moved east
                        nextMove = 3; break; //go east
                    case 4: //last moved south
                        nextMove = 4; break; //go south
                    default:
                        console.error("Unhandled prevMove=" + prevMove);
                }; break;
            case 3: //turn right
                switch(prevMove){
                    case 1: //last moved west
                        nextMove = 2; break; //go north
                    case 2: //last moved north
                        nextMove = 3; break; //go east
                    case 3: //last moved east
                        nextMove = 4; break; //go south
                    case 4: //last moved south
                        nextMove = 1; break; //go west
                    default:
                        console.error("Unhandled prevMove=" + prevMove);
                }; break;
            default:
                console.error("Unhandled turnLeftStraightRight=" + turnLeftStraightRight);
        }
        console.log("pickNextMove:: returning nextMove=" + nextMove);
        return nextMove;
    },
};

//main
function loop() {
    requestAnimationFrame(loop);
    if (++gameSpeedCounter < 15) { // 60fps slowdown factor, higher=slower
        return;
    }
    
    gameSpeedCounter = 0;
    context.clearRect(0,0,canvas.width,canvas.height);
    
    // Random pick next direction move: int 1-3
    // 1=left turn, 2=straight, 3=right turn
    let turnLeftStraightRight = Math.round((Math.random() * (3-1) + 1));
    console.log("turnLeftStraightRight=" + turnLeftStraightRight);
    
    // check head/neck to know last move, no doubling back on neck 
    if (snake.cells.length > 1){
        let headCell = {x: snake.cells[0].x, y: snake.cells[0].y};
        let neckCell = {x: snake.cells[1].x, y: snake.cells[1].y};
        console.log("headCell{x,y}={" + headCell.x + "," + headCell.y +
                 "}, neckCell{x,y}={" + neckCell.x + "," + neckCell.y + "}" );
        
        let prevMove,nextMove = 0 //1=west, 2=north, 3=east, 4=south
        prevMove = snake.detectPrevMove(headCell, neckCell);
        nextMove = snake.pickNextMove(turnLeftStraightRight, prevMove);
        
        console.log("nextMove=" + nextMove);
        snake.handleNextMove(nextMove);
    }
    
    // move snake by new velocity (either left-turn, straight, or right-turn)
    snake.x += snake.dx;
    snake.y += snake.dy;
    
    // accumulate infinite snake body
    snake.cells.unshift({x: snake.x, y: snake.y});

    let resetGame = false;
    
    if (snake.x >= canvasSideLength || 
            snake.y >= canvasSideLength || 
            snake.x < 0 || 
            snake.y < 0){
        console.log("Grid boundary violation for canvasSideLength=" + canvasSideLength
            + ", with snake head pos {x,y}={" + snake.x + "," + snake.y 
            + " ...Setting resetGame=true");
        resetGame = true;
    }

    // draw snake one cell at a time
    context.fillStyle = 'green';
    snake.cells.forEach(function(cell, index) {
        context.fillRect(cell.x, cell.y, grid-5, grid-5); // draw in snake body, with border grid effect
        
        for (var i = index + 1; i < snake.cells.length; i++) { // check collision
            if (i===1){
                console.log("PROCESSING HEAD CELL, DRAW LASTMOVE INDICATOR???"); //TODO
            }
            if (cell.x === snake.cells[i].x && cell.y === snake.cells[i].y) { // collision, snake in body. reset
                console.log("Self-collision detected!! for cells index=" + i + ", with x,y=" 
                    + cell.x + "," + cell.y );
                console.log("Setting resetGame=true");
                resetGame = true;
            }
        }
    });

    if (resetGame){
        console.log("resetGame=true, resetting");
        snake.x = grid * startOffset;
        snake.y = grid * startOffset;
        snake.cells = [];
        snake.dx = grid;
        snake.dy = 0;
        resetGame = false;
    }
}

//// keypress handling
//document.addEventListener('keydown', function(e) {
//  if (e.which === 37) { //left arrow
//    //do something
//  }
//});

// start the game
requestAnimationFrame(loop);

</script>
</body>
</html>

